---
name: refactor-ts-for-testability
description: "Refactor AI-generated JS/TS into reusable, testable modules without changing behavior; isolate side effects and add tests."
---

## Purpose
Refactor AI-generated JS/TS into reusable, testable modules without changing behavior; isolate side effects and add tests.

You are refactoring JavaScript/TypeScript code that was generated by AI.

## Non-negotiable constraints
- Do not change external behavior (public APIs, runtime outputs, error behavior, side effects).
- No big-bang rewrite. Keep diffs small and reviewable (prefer multiple small commits/steps).
- Add or improve tests as you refactor (tests are required, not optional).
- Isolate side effects behind interfaces and inject them.
- Prefer pure functions for core logic.
- No new libraries unless required for tests, lint, or types—and only with clear justification.

## What counts as a side effect (must be isolated)
Anything that touches the outside world or is non-deterministic:
- Network: fetch/axios/graphql/ws
- Data stores: DB clients, Redis, localStorage/sessionStorage, filesystem
- Time & randomness: Date.now/new Date(), setTimeout/setInterval, Math.random, crypto random
- Environment/process: process.env, process.cwd, process.exit, global state/singletons
- UI/DOM: document/window (in frontend), navigation, cookies
- Logging/metrics: console, telemetry clients

## SOLID guardrails (apply pragmatically)
Use SOLID as decision rules to improve testability and reuse—not as an excuse to add abstractions.

S — Single Responsibility
- Split parsing/validation, business rules, and side effects into separate functions/modules.
- Keep business rules as small, pure functions.

O — Open/Closed
- Prefer composition/strategy maps over long if/switch chains when supporting variants.

L — Liskov
- Avoid deep inheritance. If inheritance exists, subclasses must be drop-in replacements.
- If not true, refactor toward composition.

I — Interface Segregation
- Define small focused ports: Clock, Logger, HttpClient, Repo, Storage.
- Avoid mega-interfaces that force unused methods.

D — Dependency Inversion
- Core logic/services depend only on interfaces/types.
- Infrastructure/adapters implement interfaces and are injected at boundaries.

## Avoid SOLID theater (critical)
- Do NOT introduce classes/interfaces unless they remove duplication OR enable testing/mocking OR clarify boundaries.
- Prefer simple functions + explicit dependency parameters over DI containers/frameworks.
- Do NOT create “one interface per file” if it doesn’t improve tests or reuse.
- Do NOT reorganize the whole repo; limit file moves unless clearly beneficial.

## Testing rules (must follow)
- Write meaningful assertions (no “should run” tests).
- Prefer table-driven tests for pure functions.
- For services/orchestration, mock side-effect ports and assert:
  - correct calls to dependencies
  - correct outputs/errors
- No real network/time/random in unit tests.
- Include at least: happy path, edge case, failure path.

## Workflow (must follow in order)
1) Baseline
   - Describe current behavior: inputs/outputs, side effects, error cases.
   - Identify risky areas (shared mutable state, hidden globals, IO inside logic, tight coupling).
2) Characterization tests
   - Add tests that lock in current behavior (including edge cases).
   - If behavior is unclear, list assumptions and pick the least risky default.
3) Create seams
   - Extract pure helper functions from mixed logic.
   - Move side-effectful code into adapter functions.
4) Dependency boundaries
   - Define minimal ports (e.g., Clock, HttpClient, Repo, Logger).
   - Refactor code to accept dependencies via parameters/constructors.
5) Module structure
   - Split into: domain (pure), use-cases/services (orchestration), adapters (IO).
   - Keep boundaries enforceable: domain must not import adapters.
6) Proof
   - Ensure tests pass.
   - Provide a short before/after explanation and any remaining tech debt.

## Output format
- Diagnosis (bullets)
- Step plan (3–8 steps)
- Code changes (only changed files)
- Tests + commands to run
- Notes on remaining risks/tech debt
